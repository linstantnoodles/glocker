#!/usr/bin/env ruby
require 'open-uri'
require 'net/https'
require 'fileutils'
require 'json'
require 'yaml'

DIR = "#{Dir.home}/.glocker/"
CREDENTIALS_FILE = "#{DIR}secrets.yaml"

def fetch_jira_ticket_data(key)
  username = load_secrets['jira_username']
  password = load_secrets['jira_password']
  url = "https://jira.2u.com/rest/api/2/issue/#{key}?fields=assignee,summary,issuetype"

  open(url, http_basic_authentication: [username, password]) {|f| return JSON.parse(f.read) }
end

def load_secrets
  YAML.load_file(CREDENTIALS_FILE)
end

def create_and_checkout_branch_from_latest_master(name)
  system('git checkout master')
  system('git pull')
  system("git checkout -b #{name}")
end

def edit_pr(branch_name, body)
  dir = ticket_dir(branch_name)
  pr_file_name = "#{dir}pull-request.md"
  new_pr_file = File.new(pr_file_name, 'w')
  new_pr_file.write(body)
  new_pr_file.close
  system("cat #{pr_file_name} | vim - +'w! #{pr_file_name}'")
  updated_file = File.new(pr_file_name, 'r')
  content = updated_file.read
  content
end

def create_pr_for_current_branch
  print "Pushing branch to remote ...\n"

  `git push`

  github_token = load_secrets['github_token']
  root_project_dir = `git rev-parse --show-toplevel`
  pr_template_path = "#{root_project_dir.strip}/.github/pull_request_template.md"
  branch = `git rev-parse --abbrev-ref HEAD`.strip
  res = read_ticket_file(branch)
  key = res['key'].upcase
  summary = res['summary']
  type = res['type']
  title = "[#{key}][#{type}] #{summary}"
  body = format_template_file(pr_template_path, substitution: [
    "https://jira.2u.com/browse/<your-ticket-id>",
    "https://jira.2u.com/browse/#{key}"
  ])

  body = edit_pr(branch, body)

  remote_origin = `git config --get remote.origin.url`
  matches = remote_origin.match(/(git@github\.com):(\w+)\/(\w+)\.git/)
  owner = matches[2]
  repo = matches[3]
  print "Creating PR with title for project #{repo} for owner #{owner}: \n"
  print "\n"
  print "#{title}\n"
  print "-------------\n"
  print "#{body}\n"

  STDOUT.puts "Confirm? y/n"
  input = STDIN.gets.chomp
  raise "Aborting PR Creation." unless input.downcase == 'y'
  print "Creating PR ...\n"
  print "\n"
  data = {
    title: title,
    body: body,
    head: branch,
    base: 'master'
  }
  api_endpoint = "https://api.github.com/repos/#{owner}/#{repo}/pulls?access_token=#{github_token}"
  uri = URI.parse(api_endpoint)
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true
  request = Net::HTTP::Post.new(uri.request_uri)
  request['Content-Type'] = 'applicaton/json'
  request.body = data.to_json
  response = http.request(request)
  if response.code != '201'
    p response.body
  end
end

def format_template_file(path, substitution:)
  f = File.new(path, 'r')
  contents = f.read
  contents.gsub(substitution[0], substitution[1])
end

def open_ticket_in_curr_branch
  branch = `git rev-parse --abbrev-ref HEAD`
  res = read_ticket_file(branch.strip)
  url = "https://jira.2u.com/browse/#{res['key']}"
  `open #{url}`
end

def ticket_dir(branch_name)
  "#{DIR}#{branch_name}/"
end

def read_ticket_file(name)
  f = File.new("#{DIR}#{name}/ticket.json", 'r')
  JSON.parse(f.read)
end

def create_ticket_file(name, data)
  issue_dir = ticket_dir(name)
  if !Dir.exists?(issue_dir)
    FileUtils.mkdir_p(issue_dir)
  end
  f = File.new("#{issue_dir}ticket.json", 'w')
  f.write(data.to_json)
end

def checkout_new_branch_by_issue_key(issue_key)
  issue = fetch_jira_ticket_data(issue_key)
  fields = issue['fields']
  issue_type_name = fields['issuetype']['name']
  issue_summary = fields['summary']

  print "Creating new branch for [#{issue_key}] #{issue_summary} ...\n"
  branch_name = "#{issue_key.downcase}-#{issue_type_name.downcase}"
  create_and_checkout_branch_from_latest_master(branch_name)

  print "Creating glocker ticket file #{branch_name} ... \n"
  create_ticket_file(branch_name, {
    key: issue_key,
    summary: issue_summary,
    type: issue_type_name,
    date_created: Time.now.utc
  })
end

subcommands = [
  'cob',
  'open',
  'pr'
]
subcommand = ARGV[0]
if !subcommands.include?(subcommand)
  p "Accepted subcommands #{subcommands}"
  exit
end
if subcommand == 'cob'
  issue_key = ARGV[1]
  if !issue_key
    p "Please provide an issue key (i.e app-11)"
    exit
  end
  checkout_new_branch_by_issue_key(issue_key)
elsif subcommand == 'open'
  open_ticket_in_curr_branch
elsif subcommand == 'pr'
  create_pr_for_current_branch
end
